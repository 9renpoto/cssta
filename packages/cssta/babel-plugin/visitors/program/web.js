/* eslint-disable no-param-reassign */
const fs = require("fs");
const p = require("path");
const mkdirp = require("mkdirp");
const _ = require("lodash/fp");
const { fileStartEndCommentMarkers } = require("../../webUtil");

const writeToFile = (filename, contents) => {
  mkdirp.sync(p.dirname(filename));
  fs.writeFileSync(filename, contents, {
    encoding: "utf-8",
    flag: "w+"
  });
};

const getCssOutput = state => {
  const output = _.getOr("styles.css", ["opts", "output"], state);

  if (typeof output === "function") {
    let value = "";
    return {
      unlink: () => {},
      read: () => value,
      write: contents => {
        value = contents;
        output(contents);
      }
    };
  }

  const cssFilename = p.resolve(state.opts.cwd || process.cwd(), output);

  return {
    unlink: () => _.attempt(() => fs.unlinkSync(cssFilename)),
    read: () => _.attempt(() => fs.readFileSync(cssFilename, "utf-8")),
    write: contents => writeToFile(cssFilename, contents)
  };
};

const removeRange = (startIndex, endIndex, text) =>
  text.slice(0, startIndex) + text.slice(endIndex + 1);

const removeBetween = (startToken, endToken, text) => {
  const startIndex = text.indexOf(startToken);
  const endIndex = text.lastIndexOf(endToken);
  return startIndex !== -1 && endIndex !== -1
    ? removeRange(startIndex, endIndex, text)
    : text;
};

let previousWebCss;
module.exports = {
  enter: (path, state) => {
    const cssOutput = getCssOutput(state);

    if (!state.didRemoveCssFile) {
      cssOutput.unlink();
      state.didRemoveCssFile = true;
    }

    let { currentWebCss } = state;

    if (!currentWebCss && !state.didRemoveCssFile) {
      currentWebCss = cssOutput.read();
    }

    if (!currentWebCss || _.isError(currentWebCss)) {
      currentWebCss = "/* File generated by babel-plugin-cssta */\n";
    }

    const { commentStartMarker, commentEndMarker } = fileStartEndCommentMarkers(
      state
    );
    currentWebCss = removeBetween(
      commentStartMarker,
      commentEndMarker,
      currentWebCss
    );

    state.currentWebCss = currentWebCss;
    previousWebCss = currentWebCss;
  },
  exit: (path, state) => {
    const { currentWebCss } = state;
    if (currentWebCss === previousWebCss) return;

    const cssOutput = getCssOutput(state);
    cssOutput.write(currentWebCss);
    previousWebCss = currentWebCss;
  }
};
