const fs = require('fs');
const path = require('path');
const mkdirp = require('mkdirp');
const t = require('babel-types');
const _ = require('lodash/fp');
const extractRules = require('cssta/src/extractRules');
const cssNameGenerator = require('css-class-generator');

const animationKeywords = [
  'alternate',
  'alternate-reverse',
  'backwards',
  'both',
  'ease',
  'ease-in',
  'ease-in-out',
  'ease-out',
  'forwards',
  'infinite',
  'linear',
  'none',
  'normal',
  'paused',
  'reverse',
  'running',
  'step-end',
  'step-start',
  'initial',
  'inherit',
  'unset',
];

const classGenerator = cssNameGenerator();
const animationGenerator = (function* animationGenerator() {
  for (const value of cssNameGenerator()) {
    if (!_.includes(value, animationKeywords)) yield value;
  }
}());

const expressionTypes = {
  CallExpression: element => [element.callee, element.arguments[0]],
  MemberExpression: element => [
    element.object,
    element.computed ? element.property : t.stringLiteral(element.property.name),
  ],
};

const jsonToNode = (object) => {
  if (typeof object === 'string') {
    return t.stringLiteral(object);
  }
  return t.objectExpression(Object.keys(object).map(key => (
    t.objectProperty(
      t.identifier(key),
      jsonToNode(object[key])
    )
  )));
};

module.exports = () => ({
  visitor: {
    ImportDeclaration(element, state) {
      if (element.node.source.value === 'cssta') {
        const defaultSpecifiers = _.flow(
          _.filter({ type: 'ImportDefaultSpecifier' }),
          _.map('local.name'),
          _.compact
        )(element.node.specifiers);

        const filename = state.file.opts.filename;
        state.csstaReferencesPerFile = _.update( // eslint-disable-line
          [filename],
          existingRefereces => _.concat(existingRefereces || [], defaultSpecifiers),
          state.csstaReferencesPerFile || {}
        );

        if (!_.get(['createComponentReferencePerFile', filename], state)) {
          const reference = element.scope.generateUidIdentifier('csstaCreateComponent');
          state.createComponentReferencePerFile = _.set( // eslint-disable-line
            [filename],
            reference,
            state.createComponentReferencePerFile
          );
          const newImport = t.importDeclaration([
            t.importDefaultSpecifier(reference),
          ], t.stringLiteral('cssta/lib/createComponent'));
          element.replaceWith(newImport);
        } else {
          element.remove();
        }
      }
    },
    TaggedTemplateExpression(element, state) {
      const { quasi, tag } = element.node;

      if (!(tag.type in expressionTypes)) return;

      const [callee, elementType] = expressionTypes[tag.type](tag);

      if (callee.type !== 'Identifier') return;

      const filename = state.file.opts.filename;
      const references = _.getOr([], [filename], state.csstaReferencesPerFile);

      if (references.indexOf(callee.name) === -1) return;

      if (quasi.expressions.length > 0) {
        throw new Error('You cannot use interpolation in template strings (i.e. `color: ${primary}`)'); // eslint-disable-line
      }

      const css = _.get(['quasis', 0, 'value', 'raw'], quasi);

      state.outputIndexPerFile = _.update( // eslint-disable-line
        [filename],
        index => (index || 0) + 1,
        state.outputIndexPerFile || {}
      );

      const index = _.get([filename], state.outputIndexPerFile);

      const cssFilename = path.resolve(
        process.cwd(),
        _.getOr('styles.css', ['opts', 'output'], state)
      );
      let existingCss;

      try {
        existingCss = fs.readFileSync(cssFilename, 'utf-8');
      } catch (e) {
        existingCss = '/* File generated by babel-plugin-cssta */\n';
      }

      const commentMarker = `/* ${filename.replace(/\*/g, '')} (index: ${index}) */`;

      if (existingCss.indexOf(commentMarker) !== -1) {
        throw new Error('You must remove the existing CSS file before running files through babel');
      }

      const { css: output, baseClassName, classNameMap } = extractRules(css, {
        generateClassName: () => classGenerator.next().value,
        generateAnimationName: () => animationGenerator.next().value,
      });

      const outputCss = `${existingCss}\n${commentMarker}\n${output}\n`;

      mkdirp.sync(path.dirname(cssFilename));
      fs.writeFileSync(cssFilename, outputCss, {
        encoding: 'utf-8',
        flag: 'w+',
      });

      const createElement = state.createComponentReferencePerFile[filename];
      const newElement = t.callExpression(createElement, [
        elementType,
        t.stringLiteral(baseClassName),
        jsonToNode(classNameMap),
      ]);
      element.replaceWith(newElement);
    },
  },
});
